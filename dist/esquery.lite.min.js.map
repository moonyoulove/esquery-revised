{"version":3,"file":"esquery.lite.min.js","sources":["../parser.js","../esquery.js"],"sourcesContent":["/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  }\n})(this, function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = function(ss) {\r\n            return ss.length === 1 ? ss[0] : { type: 'matches', selectors: ss };\r\n          },\n        peg$c1 = function() { return void 0; },\n        peg$c2 = \" \",\n        peg$c3 = peg$literalExpectation(\" \", false),\n        peg$c4 = /^[^ [\\],():#!=><~+.]/,\n        peg$c5 = peg$classExpectation([\" \", \"[\", \"]\", \",\", \"(\", \")\", \":\", \"#\", \"!\", \"=\", \">\", \"<\", \"~\", \"+\", \".\"], true, false),\n        peg$c6 = function(i) { return i.join(''); },\n        peg$c7 = \">\",\n        peg$c8 = peg$literalExpectation(\">\", false),\n        peg$c9 = function() { return 'child'; },\n        peg$c10 = \"~\",\n        peg$c11 = peg$literalExpectation(\"~\", false),\n        peg$c12 = function() { return 'sibling'; },\n        peg$c13 = \"+\",\n        peg$c14 = peg$literalExpectation(\"+\", false),\n        peg$c15 = function() { return 'adjacent'; },\n        peg$c16 = function() { return 'descendant'; },\n        peg$c17 = \",\",\n        peg$c18 = peg$literalExpectation(\",\", false),\n        peg$c19 = function(s, ss) {\r\n          return [s].concat(ss.map(function (s) { return s[3]; }));\r\n        },\n        peg$c20 = function(a, ops) {\r\n            return ops.reduce(function (memo, rhs) {\r\n              return { type: rhs[0], left: memo, right: rhs[1] };\r\n            }, a);\r\n          },\n        peg$c21 = \"!\",\n        peg$c22 = peg$literalExpectation(\"!\", false),\n        peg$c23 = function(subject, as) {\r\n            const b = as.length === 1 ? as[0] : { type: 'compound', selectors: as };\r\n            if(subject) b.subject = true;\r\n            return b;\r\n          },\n        peg$c24 = \"*\",\n        peg$c25 = peg$literalExpectation(\"*\", false),\n        peg$c26 = function(a) { return { type: 'wildcard', value: a }; },\n        peg$c27 = \"#\",\n        peg$c28 = peg$literalExpectation(\"#\", false),\n        peg$c29 = function(i) { return { type: 'identifier', value: i }; },\n        peg$c30 = \"[\",\n        peg$c31 = peg$literalExpectation(\"[\", false),\n        peg$c32 = \"]\",\n        peg$c33 = peg$literalExpectation(\"]\", false),\n        peg$c34 = function(v) { return v; },\n        peg$c35 = /^[><!]/,\n        peg$c36 = peg$classExpectation([\">\", \"<\", \"!\"], false, false),\n        peg$c37 = \"=\",\n        peg$c38 = peg$literalExpectation(\"=\", false),\n        peg$c39 = function(a) { return (a || '') + '='; },\n        peg$c40 = /^[><]/,\n        peg$c41 = peg$classExpectation([\">\", \"<\"], false, false),\n        peg$c42 = \".\",\n        peg$c43 = peg$literalExpectation(\".\", false),\n        peg$c44 = function(a, as) {\r\n            return [].concat.apply([a], as).join('');\r\n          },\n        peg$c45 = function(name, op, value) {\r\n              return { type: 'attribute', name: name, operator: op, value: value };\r\n            },\n        peg$c46 = function(name) { return { type: 'attribute', name: name }; },\n        peg$c47 = \"\\\"\",\n        peg$c48 = peg$literalExpectation(\"\\\"\", false),\n        peg$c49 = /^[^\\\\\"]/,\n        peg$c50 = peg$classExpectation([\"\\\\\", \"\\\"\"], true, false),\n        peg$c51 = \"\\\\\",\n        peg$c52 = peg$literalExpectation(\"\\\\\", false),\n        peg$c53 = peg$anyExpectation(),\n        peg$c54 = function(a, b) { return a + b; },\n        peg$c55 = function(d) {\r\n                return { type: 'literal', value: strUnescape(d.join('')) };\r\n              },\n        peg$c56 = \"'\",\n        peg$c57 = peg$literalExpectation(\"'\", false),\n        peg$c58 = /^[^\\\\']/,\n        peg$c59 = peg$classExpectation([\"\\\\\", \"'\"], true, false),\n        peg$c60 = /^[0-9]/,\n        peg$c61 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c62 = function(a, b) {\r\n                // Can use `a.flat().join('')` once supported\r\n                const leadingDecimals = a ? [].concat.apply([], a).join('') : '';\r\n                return { type: 'literal', value: parseFloat(leadingDecimals + b.join('')) };\r\n              },\n        peg$c63 = function(i) { return { type: 'literal', value: i }; },\n        peg$c64 = \"type(\",\n        peg$c65 = peg$literalExpectation(\"type(\", false),\n        peg$c66 = /^[^ )]/,\n        peg$c67 = peg$classExpectation([\" \", \")\"], true, false),\n        peg$c68 = \")\",\n        peg$c69 = peg$literalExpectation(\")\", false),\n        peg$c70 = function(t) { return { type: 'type', value: t.join('') }; },\n        peg$c71 = /^[imsu]/,\n        peg$c72 = peg$classExpectation([\"i\", \"m\", \"s\", \"u\"], false, false),\n        peg$c73 = \"/\",\n        peg$c74 = peg$literalExpectation(\"/\", false),\n        peg$c75 = /^[^\\/]/,\n        peg$c76 = peg$classExpectation([\"/\"], true, false),\n        peg$c77 = function(d, flgs) { return {\r\n              type: 'regexp', value: new RegExp(d.join(''), flgs ? flgs.join('') : '') };\r\n            },\n        peg$c78 = function(i, is) {\r\n          return { type: 'field', name: is.reduce(function(memo, p){ return memo + p[0] + p[1]; }, i)};\r\n        },\n        peg$c79 = \":not(\",\n        peg$c80 = peg$literalExpectation(\":not(\", false),\n        peg$c81 = function(ss) { return { type: 'not', selectors: ss }; },\n        peg$c82 = \":matches(\",\n        peg$c83 = peg$literalExpectation(\":matches(\", false),\n        peg$c84 = function(ss) { return { type: 'matches', selectors: ss }; },\n        peg$c85 = \":has(\",\n        peg$c86 = peg$literalExpectation(\":has(\", false),\n        peg$c87 = function(ss) { return { type: 'has', selectors: ss }; },\n        peg$c88 = \":first-child\",\n        peg$c89 = peg$literalExpectation(\":first-child\", false),\n        peg$c90 = function() { return nth(1); },\n        peg$c91 = \":last-child\",\n        peg$c92 = peg$literalExpectation(\":last-child\", false),\n        peg$c93 = function() { return nthLast(1); },\n        peg$c94 = \":nth-child(\",\n        peg$c95 = peg$literalExpectation(\":nth-child(\", false),\n        peg$c96 = function(n) { return nth(parseInt(n.join(''), 10)); },\n        peg$c97 = \":nth-last-child(\",\n        peg$c98 = peg$literalExpectation(\":nth-last-child(\", false),\n        peg$c99 = function(n) { return nthLast(parseInt(n.join(''), 10)); },\n        peg$c100 = \":scope\",\n        peg$c101 = peg$literalExpectation(\":scope\", false),\n        peg$c102 = function() { return { type: 'scope' }; },\n        peg$c103 = \":\",\n        peg$c104 = peg$literalExpectation(\":\", false),\n        peg$c105 = function(c) {\r\n          return { type: 'class', name: c };\r\n        },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$resultsCache = {},\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 31 + 0,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseselectors();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1;\n\n      var key    = peg$currPos * 31 + 1,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c2;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s1 = peg$c2;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c3); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseidentifierName() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 31 + 2,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c4.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsebinaryOp() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 31 + 3,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s2 = peg$c7;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c9();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 126) {\n            s2 = peg$c10;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c11); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c12();\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 43) {\n              s2 = peg$c13;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c14); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c15();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 32) {\n              s1 = peg$c2;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c3); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c16();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselectors() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 31 + 4,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseselector();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c17;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseselector();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c17;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c18); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseselector();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c19(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselector() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 31 + 5,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsesequence();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parsebinaryOp();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsesequence();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parsebinaryOp();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesequence();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c20(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesequence() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 31 + 6,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c21;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseatom();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseatom();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c23(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseatom() {\n      var s0;\n\n      var key    = peg$currPos * 31 + 7,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsewildcard();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseidentifier();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseattr();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsefield();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsenegation();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsematches();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsehas();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsefirstChild();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parselastChild();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsenthChild();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsenthLastChild();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsescope();\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parseclass();\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsewildcard() {\n      var s0, s1;\n\n      var key    = peg$currPos * 31 + 8,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s1 = peg$c24;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseidentifier() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 31 + 9,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 35) {\n        s1 = peg$c27;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c28); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattr() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 31 + 10,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c30;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseattrValue();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s5 = peg$c32;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c33); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c34(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrOps() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 31 + 11,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c35.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c37;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c39(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        if (peg$c40.test(input.charAt(peg$currPos))) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c41); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrEqOps() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 31 + 12,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c21;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c37;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c39(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrName() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 31 + 13,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifierName();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s4 = peg$c42;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c43); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseidentifierName();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s4 = peg$c42;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c43); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidentifierName();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c44(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrValue() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 31 + 14,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseattrName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseattrEqOps();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsetype();\n              if (s5 === peg$FAILED) {\n                s5 = peg$parseregex();\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c45(s1, s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseattrName();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseattrOps();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsestring();\n                if (s5 === peg$FAILED) {\n                  s5 = peg$parsenumber();\n                  if (s5 === peg$FAILED) {\n                    s5 = peg$parsepath();\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c45(s1, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseattrName();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c46(s1);\n          }\n          s0 = s1;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsestring() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 31 + 15,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c47;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c49.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c50); }\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s4 = peg$c51;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c52); }\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c54(s4, s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c49.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c50); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c51;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c52); }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c53); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c54(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c47;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c48); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c55(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s1 = peg$c56;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c57); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          if (peg$c58.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c59); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c51;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c52); }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c53); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c54(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c58.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c59); }\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c51;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c52); }\n              }\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c53); }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s4 = peg$c54(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s3 = peg$c56;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c57); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c55(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 31 + 16,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c60.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$c60.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c61); }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c42;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c43); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c60.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c61); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c61); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c62(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1;\n\n      var key    = peg$currPos * 31 + 17,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifierName();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c63(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetype() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 31 + 18,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c64) {\n        s1 = peg$c64;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c65); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c66.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c67); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c66.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c67); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c70(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseflags() {\n      var s0, s1;\n\n      var key    = peg$currPos * 31 + 19,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (peg$c71.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c72); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c71.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c72); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseregex() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 31 + 20,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c73;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c75.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c76); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c75.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c76); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s3 = peg$c73;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c74); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseflags();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c77(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefield() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 31 + 21,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s1 = peg$c42;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c43); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s5 = peg$c42;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c43); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseidentifierName();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s5 = peg$c42;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c43); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseidentifierName();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c78(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenegation() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 31 + 22,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c79) {\n        s1 = peg$c79;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c80); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c81(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsematches() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 31 + 23,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 9) === peg$c82) {\n        s1 = peg$c82;\n        peg$currPos += 9;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c83); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c84(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehas() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 31 + 24,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c85) {\n        s1 = peg$c85;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c86); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c87(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefirstChild() {\n      var s0, s1;\n\n      var key    = peg$currPos * 31 + 25,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 12) === peg$c88) {\n        s1 = peg$c88;\n        peg$currPos += 12;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c89); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c90();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselastChild() {\n      var s0, s1;\n\n      var key    = peg$currPos * 31 + 26,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c91) {\n        s1 = peg$c91;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c92); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c93();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenthChild() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 31 + 27,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c94) {\n        s1 = peg$c94;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c95); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c61); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c61); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c96(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenthLastChild() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 31 + 28,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 16) === peg$c97) {\n        s1 = peg$c97;\n        peg$currPos += 16;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c98); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c61); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c61); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c99(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope() {\n      var s0, s1;\n\n      var key    = peg$currPos * 31 + 29,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6) === peg$c100) {\n        s1 = peg$c100;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c101); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c102();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseclass() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 31 + 30,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c103;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c104); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c105(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\r\n      function nth(n) { return { type: 'nth-child', index: { type: 'literal', value: n } }; }\r\n      function nthLast(n) { return { type: 'nth-last-child', index: { type: 'literal', value: n } }; }\r\n      function strUnescape(s) {\r\n        return s.replace(/\\\\(.)/g, function(match, ch) {\r\n          switch(ch) {\r\n            case 'b': return '\\b';\r\n            case 'f': return '\\f';\r\n            case 'n': return '\\n';\r\n            case 'r': return '\\r';\r\n            case 't': return '\\t';\r\n            case 'v': return '\\v';\r\n            default: return ch;\r\n          }\r\n        });\r\n      }\r\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n});\n","/* vim: set sw=4 sts=4 : */\r\nimport estraverse from 'estraverse';\r\nimport parser from './parser.js';\r\n\r\n/**\r\n* @typedef {\"LEFT_SIDE\"|\"RIGHT_SIDE\"} Side\r\n*/\r\n\r\nconst LEFT_SIDE = 'LEFT_SIDE';\r\nconst RIGHT_SIDE = 'RIGHT_SIDE';\r\n\r\n/**\r\n * @external AST\r\n * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html\r\n */\r\n\r\n/**\r\n * One of the rules of `grammar.pegjs`\r\n * @typedef {PlainObject} SelectorAST\r\n * @see grammar.pegjs\r\n*/\r\n\r\n/**\r\n * The `sequence` production of `grammar.pegjs`\r\n * @typedef {PlainObject} SelectorSequenceAST\r\n*/\r\n\r\n/**\r\n * Get the value of a property which may be multiple levels down\r\n * in the object.\r\n * @param {?PlainObject} obj\r\n * @param {string[]} keys\r\n * @returns {undefined|boolean|string|number|external:AST}\r\n */\r\nfunction getPath(obj, keys) {\r\n    for (let i = 0; i < keys.length; ++i) {\r\n        if (obj == null) { return obj; }\r\n        obj = obj[keys[i]];\r\n    }\r\n    return obj;\r\n}\r\n\r\n/**\r\n * Determine whether `node` can be reached by following `path`,\r\n * starting at `ancestor`.\r\n * @param {?external:AST} node\r\n * @param {?external:AST} ancestor\r\n * @param {string[]} path\r\n * @param {Integer} fromPathIndex\r\n * @returns {boolean}\r\n */\r\nfunction inPath(node, ancestor, path, fromPathIndex) {\r\n    let current = ancestor;\r\n    for (let i = fromPathIndex; i < path.length; ++i) {\r\n        if (current == null) {\r\n            return false;\r\n        }\r\n        const field = current[path[i]];\r\n        if (Array.isArray(field)) {\r\n            for (let k = 0; k < field.length; ++k) {\r\n                if (inPath(node, field[k], path, i + 1)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        current = field;\r\n    }\r\n    return node === current;\r\n}\r\n\r\n/**\r\n * A generated matcher function for a selector.\r\n * @typedef {function} SelectorMatcher\r\n*/\r\n\r\n/**\r\n * A WeakMap for holding cached matcher functions for selectors.\r\n * @type {WeakMap<SelectorAST, SelectorMatcher>}\r\n*/\r\nconst MATCHER_CACHE = typeof WeakMap === 'function' ? new WeakMap : null;\r\n\r\n/**\r\n * Look up a matcher function for `selector` in the cache.\r\n * If it does not exist, generate it with `generateMatcher` and add it to the cache.\r\n * In engines without WeakMap, the caching is skipped and matchers are generated with every call.\r\n * @param {?SelectorAST} selector\r\n * @returns {SelectorMatcher}\r\n */\r\nfunction getMatcher(selector) {\r\n    if (selector == null) {\r\n        return () => true;\r\n    }\r\n\r\n    if (MATCHER_CACHE != null) {\r\n        let matcher = MATCHER_CACHE.get(selector);\r\n        if (matcher != null) {\r\n            return matcher;\r\n        }\r\n        matcher = generateMatcher(selector);\r\n        MATCHER_CACHE.set(selector, matcher);\r\n        return matcher;\r\n    }\r\n\r\n    return generateMatcher(selector);\r\n}\r\n\r\n/**\r\n * Create a matcher function for `selector`,\r\n * @param {?SelectorAST} selector\r\n * @returns {SelectorMatcher}\r\n */\r\nfunction generateMatcher(selector) {\r\n    switch(selector.type) {\r\n        case 'wildcard':\r\n            return () => true;\r\n\r\n        case 'identifier': {\r\n            const value = selector.value.toLowerCase();\r\n            return (node, ancestry, options) => {\r\n                const nodeTypeKey = (options && options.nodeTypeKey) || 'type';\r\n                return value === node[nodeTypeKey].toLowerCase();\r\n            };\r\n        }\r\n\r\n        case 'field': {\r\n            const path = selector.name.split('.');\r\n            return (node, ancestry) => {\r\n                const ancestor = ancestry[path.length - 1];\r\n                return inPath(node, ancestor, path, 0);\r\n            };\r\n        }\r\n\r\n        case 'matches': {\r\n            const matchers = selector.selectors.map(getMatcher);\r\n            return (node, ancestry, options) => {\r\n                for (let i = 0; i < matchers.length; ++i) {\r\n                    if (matchers[i](node, ancestry, options)) { return true; }\r\n                }\r\n                return false;\r\n            };\r\n        }\r\n\r\n        case 'compound': {\r\n            const matchers = selector.selectors.map(getMatcher);\r\n            return (node, ancestry, options) => {\r\n                for (let i = 0; i < matchers.length; ++i) {\r\n                    if (!matchers[i](node, ancestry, options)) { return false; }\r\n                }\r\n                return true;\r\n            };\r\n        }\r\n\r\n        case 'not': {\r\n            const matchers = selector.selectors.map(getMatcher);\r\n            return (node, ancestry, options) => {\r\n                for (let i = 0; i < matchers.length; ++i) {\r\n                    if (matchers[i](node, ancestry, options)) { return false; }\r\n                }\r\n                return true;\r\n            };\r\n        }\r\n\r\n        case 'has': {\r\n            const matchers = selector.selectors.map(getMatcher);\r\n            return (node, ancestry, options) => {\r\n                let result = false;\r\n\r\n                const a = [];\r\n                estraverse.traverse(node, {\r\n                    enter (node, parent) {\r\n                        if (parent != null) { a.unshift(parent); }\r\n\r\n                        for (let i = 0; i < matchers.length; ++i) {\r\n                            if (matchers[i](node, a, options)) {\r\n                                result = true;\r\n                                this.break();\r\n                                return;\r\n                            }\r\n                        }\r\n                    },\r\n                    leave () { a.shift(); },\r\n                    keys: options && options.visitorKeys,\r\n                    fallback: options && options.fallback || 'iteration'\r\n                });\r\n\r\n                return result;\r\n            };\r\n        }\r\n\r\n        case 'child': {\r\n            const left = getMatcher(selector.left);\r\n            const right = getMatcher(selector.right);\r\n            return (node, ancestry, options) => {\r\n                if (ancestry.length > 0 && right(node, ancestry, options)) {\r\n                    return left(ancestry[0], ancestry.slice(1), options);\r\n                }\r\n                return false;\r\n            };\r\n        }\r\n\r\n        case 'descendant': {\r\n            const left = getMatcher(selector.left);\r\n            const right = getMatcher(selector.right);\r\n            return (node, ancestry, options) => {\r\n                if (right(node, ancestry, options)) {\r\n                    for (let i = 0, l = ancestry.length; i < l; ++i) {\r\n                        if (left(ancestry[i], ancestry.slice(i + 1), options)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n                return false;\r\n            };\r\n        }\r\n\r\n        case 'attribute': {\r\n            const path = selector.name.split('.');\r\n            switch (selector.operator) {\r\n                case void 0:\r\n                    return (node) => getPath(node, path) != null;\r\n                case '=':\r\n                    switch (selector.value.type) {\r\n                        case 'regexp':\r\n                            return (node) => {\r\n                                const p = getPath(node, path);\r\n                                return typeof p === 'string' && selector.value.value.test(p);\r\n                            };\r\n                        case 'literal': {\r\n                            const literal = `${selector.value.value}`;\r\n                            return (node) => literal === `${getPath(node, path)}`;\r\n                        }\r\n                        case 'type':\r\n                            return (node) => selector.value.value === typeof getPath(node, path);\r\n                    }\r\n                    throw new Error(`Unknown selector value type: ${selector.value.type}`);\r\n                case '!=':\r\n                    switch (selector.value.type) {\r\n                        case 'regexp':\r\n                            return (node) => !selector.value.value.test(getPath(node, path));\r\n                        case 'literal': {\r\n                            const literal = `${selector.value.value}`;\r\n                            return (node) => literal !== `${getPath(node, path)}`;\r\n                        }\r\n                        case 'type':\r\n                            return (node) => selector.value.value !== typeof getPath(node, path);\r\n                    }\r\n                    throw new Error(`Unknown selector value type: ${selector.value.type}`);\r\n                case '<=':\r\n                    return (node) => getPath(node, path) <= selector.value.value;\r\n                case '<':\r\n                    return (node) => getPath(node, path) < selector.value.value;\r\n                case '>':\r\n                    return (node) => getPath(node, path) > selector.value.value;\r\n                case '>=':\r\n                    return (node) => getPath(node, path) >= selector.value.value;\r\n            }\r\n            throw new Error(`Unknown operator: ${selector.operator}`);\r\n        }\r\n\r\n        case 'sibling': {\r\n            const left = getMatcher(selector.left);\r\n            const right = getMatcher(selector.right);\r\n            return (node, ancestry, options) =>\r\n                right(node, ancestry, options) &&\r\n                    sibling(node, left, ancestry, LEFT_SIDE, options) ||\r\n                    selector.left.subject &&\r\n                    left(node, ancestry, options) &&\r\n                    sibling(node, right, ancestry, RIGHT_SIDE, options);\r\n        }\r\n\r\n        case 'adjacent': {\r\n            const left = getMatcher(selector.left);\r\n            const right = getMatcher(selector.right);\r\n            return (node, ancestry, options) =>\r\n                right(node, ancestry, options) &&\r\n                    adjacent(node, left, ancestry, LEFT_SIDE, options) ||\r\n                    selector.right.subject &&\r\n                    left(node, ancestry, options) &&\r\n                    adjacent(node, right, ancestry, RIGHT_SIDE, options);\r\n        }\r\n\r\n        case 'nth-child': {\r\n            const nth = selector.index.value;\r\n            const right = getMatcher(selector.right);\r\n            return (node, ancestry, options) =>\r\n                right(node, ancestry, options) &&\r\n                    nthChild(node, ancestry, nth, options);\r\n        }\r\n\r\n        case 'nth-last-child': {\r\n            const nth = -selector.index.value;\r\n            const right = getMatcher(selector.right);\r\n            return (node, ancestry, options) =>\r\n                right(node, ancestry, options) &&\r\n                    nthChild(node, ancestry, nth, options);\r\n        }\r\n\r\n        case 'class': {\r\n            \r\n            const name = selector.name.toLowerCase();\r\n\r\n            return (node, ancestry, options) => {\r\n                \r\n                if (options && options.matchClass) {\r\n                    return options.matchClass(selector.name, node, ancestry);\r\n                }\r\n                \r\n                if (options && options.nodeTypeKey) return false;    \r\n\r\n                switch(name){\r\n                    case 'statement':\r\n                        if(node.type.slice(-9) === 'Statement') return true;\r\n                        // fallthrough: interface Declaration <: Statement { }\r\n                    case 'declaration':\r\n                        return node.type.slice(-11) === 'Declaration';\r\n                    case 'pattern':\r\n                        if(node.type.slice(-7) === 'Pattern') return true;\r\n                        // fallthrough: interface Expression <: Node, Pattern { }\r\n                    case 'expression':\r\n                        return node.type.slice(-10) === 'Expression' ||\r\n                            node.type.slice(-7) === 'Literal' ||\r\n                            (\r\n                                node.type === 'Identifier' &&\r\n                                (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty')\r\n                            ) ||\r\n                            node.type === 'MetaProperty';\r\n                    case 'function':\r\n                        return node.type === 'FunctionDeclaration' ||\r\n                            node.type === 'FunctionExpression' ||\r\n                            node.type === 'ArrowFunctionExpression';\r\n                }\r\n                throw new Error(`Unknown class name: ${selector.name}`);\r\n            };\r\n        }\r\n\r\n        case 'scope': {\r\n            return (node, ancestry) => ancestry.length === 0;\r\n        }\r\n    }\r\n\r\n    throw new Error(`Unknown selector type: ${selector.type}`);\r\n}\r\n\r\n/**\r\n * @callback TraverseOptionFallback\r\n * @param {external:AST} node The given node.\r\n * @returns {string[]} An array of visitor keys for the given node.\r\n */\r\n\r\n/**\r\n * @callback ClassMatcher\r\n * @param {string} className The name of the class to match.\r\n * @param {external:AST} node The node to match against.\r\n * @param {Array<external:AST>} ancestry The ancestry of the node.\r\n * @returns {boolean} True if the node matches the class, false if not.\r\n */\r\n\r\n/**\r\n * @typedef {object} ESQueryOptions\r\n * @property {string} [nodeTypeKey=\"type\"] By passing `nodeTypeKey`, we can allow other ASTs to use ESQuery.\r\n * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\r\n * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\r\n * @property {ClassMatcher} [matchClass] By passing `matchClass` option, we can customize the interpretation of classes.\r\n */\r\n\r\n/**\r\n * Given a `node` and its ancestors, determine if `node` is matched\r\n * by `selector`.\r\n * @param {?external:AST} node\r\n * @param {?SelectorAST} selector\r\n * @param {external:AST[]} [ancestry=[]]\r\n * @param {ESQueryOptions} [options]\r\n * @throws {Error} Unknowns (operator, class name, selector type, or\r\n * selector value type)\r\n * @returns {boolean}\r\n */\r\nfunction matches(node, selector, ancestry, options) {\r\n    if (!selector) { return true; }\r\n    if (!node) { return false; }\r\n    if (!ancestry) { ancestry = []; }\r\n\r\n    return getMatcher(selector)(node, ancestry, options);\r\n}\r\n\r\n/**\r\n * Get visitor keys of a given node.\r\n * @param {external:AST} node The AST node to get keys.\r\n * @param {ESQueryOptions|undefined} options\r\n * @returns {string[]} Visitor keys of the node.\r\n */\r\nfunction getVisitorKeys(node, options) {\r\n    const nodeTypeKey = (options && options.nodeTypeKey) || 'type';\r\n\r\n    const nodeType = node[nodeTypeKey];\r\n    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\r\n        return options.visitorKeys[nodeType];\r\n    }\r\n    if (estraverse.VisitorKeys[nodeType]) {\r\n        return estraverse.VisitorKeys[nodeType];\r\n    }\r\n    if (options && typeof options.fallback === 'function') {\r\n        return options.fallback(node);\r\n    }\r\n    // 'iteration' fallback\r\n    return Object.keys(node).filter(function (key) {\r\n        return key !== nodeTypeKey;\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Check whether the given value is an ASTNode or not.\r\n * @param {any} node The value to check.\r\n * @param {ESQueryOptions|undefined} options The options to use.\r\n * @returns {boolean} `true` if the value is an ASTNode.\r\n */\r\nfunction isNode(node, options) {\r\n    const nodeTypeKey = (options && options.nodeTypeKey) || 'type';\r\n    return node !== null && typeof node === 'object' && typeof node[nodeTypeKey] === 'string';\r\n}\r\n\r\n/**\r\n * Determines if the given node has a sibling that matches the\r\n * given selector matcher.\r\n * @param {external:AST} node\r\n * @param {SelectorMatcher} matcher\r\n * @param {external:AST[]} ancestry\r\n * @param {Side} side\r\n * @param {ESQueryOptions|undefined} options\r\n * @returns {boolean}\r\n */\r\nfunction sibling(node, matcher, ancestry, side, options) {\r\n    const [parent] = ancestry;\r\n    if (!parent) { return false; }\r\n    const keys = getVisitorKeys(parent, options);\r\n    for (let i = 0; i < keys.length; ++i) {\r\n        const listProp = parent[keys[i]];\r\n        if (Array.isArray(listProp)) {\r\n            const startIndex = listProp.indexOf(node);\r\n            if (startIndex < 0) { continue; }\r\n            let lowerBound, upperBound;\r\n            if (side === LEFT_SIDE) {\r\n                lowerBound = 0;\r\n                upperBound = startIndex;\r\n            } else {\r\n                lowerBound = startIndex + 1;\r\n                upperBound = listProp.length;\r\n            }\r\n            for (let k = lowerBound; k < upperBound; ++k) {\r\n                if (isNode(listProp[k], options) && matcher(listProp[k], ancestry, options)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Determines if the given node has an adjacent sibling that matches\r\n * the given selector matcher.\r\n * @param {external:AST} node\r\n * @param {SelectorMatcher} matcher\r\n * @param {external:AST[]} ancestry\r\n * @param {Side} side\r\n * @param {ESQueryOptions|undefined} options\r\n * @returns {boolean}\r\n */\r\nfunction adjacent(node, matcher, ancestry, side, options) {\r\n    const [parent] = ancestry;\r\n    if (!parent) { return false; }\r\n    const keys = getVisitorKeys(parent, options);\r\n    for (let i = 0; i < keys.length; ++i) {\r\n        const listProp = parent[keys[i]];\r\n        if (Array.isArray(listProp)) {\r\n            const idx = listProp.indexOf(node);\r\n            if (idx < 0) { continue; }\r\n            if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1], options) && matcher(listProp[idx - 1], ancestry, options)) {\r\n                return true;\r\n            }\r\n            if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1], options) &&  matcher(listProp[idx + 1], ancestry, options)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Determines if the given node is the `nth` child.\r\n * If `nth` is negative then the position is counted\r\n * from the end of the list of children.\r\n * @param {external:AST} node\r\n * @param {external:AST[]} ancestry\r\n * @param {Integer} nth\r\n * @param {ESQueryOptions|undefined} options\r\n * @returns {boolean}\r\n */\r\nfunction nthChild(node, ancestry, nth, options) {\r\n    if (nth === 0) { return false; }\r\n    const [parent] = ancestry;\r\n    if (!parent) { return false; }\r\n    const keys = getVisitorKeys(parent, options);\r\n    for (let i = 0; i < keys.length; ++i) {\r\n        const listProp = parent[keys[i]];\r\n        if (Array.isArray(listProp)){\r\n            const idx = nth < 0 ? listProp.length + nth : nth - 1;\r\n            if (idx >= 0 && idx < listProp.length && listProp[idx] === node) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * For each selector node marked as a subject, find the portion of the\r\n * selector that the subject must match.\r\n * @param {SelectorAST} selector\r\n * @param {SelectorAST} [ancestor] Defaults to `selector`\r\n * @returns {SelectorAST[]}\r\n */\r\nfunction subjects(selector, ancestor) {\r\n    if (selector == null || typeof selector != 'object') { return []; }\r\n    if (ancestor == null) { ancestor = selector; }\r\n    const results = selector.subject ? [ancestor] : [];\r\n    const keys = Object.keys(selector);\r\n    for (let i = 0; i < keys.length; ++i) {\r\n        const p = keys[i];\r\n        const sel = selector[p];\r\n        results.push(...subjects(sel, p === 'left' ? sel : ancestor));\r\n    }\r\n    return results;\r\n}\r\n\r\n/**\r\n* @callback TraverseVisitor\r\n* @param {?external:AST} node\r\n* @param {?external:AST} parent\r\n* @param {external:AST[]} ancestry\r\n*/\r\n\r\n/**\r\n * From a JS AST and a selector AST, collect all JS AST nodes that\r\n * match the selector.\r\n * @param {external:AST} ast\r\n * @param {?SelectorAST} selector\r\n * @param {TraverseVisitor} visitor\r\n * @param {ESQueryOptions} [options]\r\n * @returns {external:AST[]}\r\n */\r\nfunction traverse(ast, selector, visitor, options) {\r\n    if (!selector) { return; }\r\n    const ancestry = [];\r\n    const matcher = getMatcher(selector);\r\n    const altSubjects = subjects(selector).map(getMatcher);\r\n    estraverse.traverse(ast, {\r\n        enter (node, parent) {\r\n            if (parent != null) { ancestry.unshift(parent); }\r\n            if (matcher(node, ancestry, options)) {\r\n                if (altSubjects.length) {\r\n                    for (let i = 0, l = altSubjects.length; i < l; ++i) {\r\n                        if (altSubjects[i](node, ancestry, options)) {\r\n                            visitor(node, parent, ancestry);\r\n                        }\r\n                        for (let k = 0, m = ancestry.length; k < m; ++k) {\r\n                            const succeedingAncestry = ancestry.slice(k + 1);\r\n                            if (altSubjects[i](ancestry[k], succeedingAncestry, options)) {\r\n                                visitor(ancestry[k], parent, succeedingAncestry);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    visitor(node, parent, ancestry);\r\n                }\r\n            }\r\n        },\r\n        leave () { ancestry.shift(); },\r\n        keys: options && options.visitorKeys,\r\n        fallback: options && options.fallback || 'iteration'\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * From a JS AST and a selector AST, collect all JS AST nodes that\r\n * match the selector.\r\n * @param {external:AST} ast\r\n * @param {?SelectorAST} selector\r\n * @param {ESQueryOptions} [options]\r\n * @returns {external:AST[]}\r\n */\r\nfunction match(ast, selector, options) {\r\n    const results = [];\r\n    traverse(ast, selector, function (node) {\r\n        results.push(node);\r\n    }, options);\r\n    return results;\r\n}\r\n\r\n/**\r\n * Parse a selector string and return its AST.\r\n * @param {string} selector\r\n * @returns {SelectorAST}\r\n */\r\nfunction parse(selector) {\r\n    return parser.parse(selector);\r\n}\r\n\r\n/**\r\n * Query the code AST using the selector string.\r\n * @param {external:AST} ast\r\n * @param {string} selector\r\n * @param {ESQueryOptions} [options]\r\n * @returns {external:AST[]}\r\n */\r\nfunction query(ast, selector, options) {\r\n    return match(ast, parse(selector), options);\r\n}\r\n\r\nquery.parse = parse;\r\nquery.match = match;\r\nquery.traverse = traverse;\r\nquery.matches = matches;\r\nquery.query = query;\r\n\r\nexport default query;\r\n"],"names":["module","exports","peg$SyntaxError","message","expected","found","location","this","name","Error","captureStackTrace","child","parent","ctor","constructor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","class","i","escapedParts","parts","length","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","s","replace","j","descriptions","type","sort","slice","join","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c3","peg$literalExpectation","peg$c4","peg$c5","peg$classExpectation","peg$c8","peg$c11","peg$c14","peg$c18","peg$c22","peg$c25","peg$c28","peg$c31","peg$c33","peg$c35","peg$c36","peg$c38","peg$c39","a","peg$c40","peg$c41","peg$c43","peg$c45","op","value","operator","peg$c48","peg$c49","peg$c50","peg$c52","peg$c53","peg$c54","b","peg$c55","d","match","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c65","peg$c66","peg$c67","peg$c69","peg$c71","peg$c72","peg$c74","peg$c75","peg$c76","peg$c80","peg$c83","peg$c86","peg$c89","peg$c92","peg$c95","peg$c98","peg$c101","peg$c104","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$resultsCache","startRule","ignoreCase","peg$computePosDetails","pos","p","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","offset","peg$fail","push","s0","s1","s2","ss","key","cached","nextPos","result","peg$parse_","peg$parseselectors","selectors","peg$c1","peg$parseidentifierName","test","charAt","peg$parsebinaryOp","s3","s4","s5","s6","s7","peg$parseselector","concat","map","peg$parsesequence","reduce","memo","rhs","left","right","subject","as","peg$parseatom","peg$parsewildcard","peg$parseidentifier","peg$parseattrName","peg$parseattrEqOps","substr","peg$parsetype","flgs","peg$parseflags","RegExp","peg$parseregex","peg$parseattrOps","peg$parsestring","leadingDecimals","apply","parseFloat","peg$parsenumber","peg$parsepath","peg$parseattrValue","peg$parseattr","peg$parsefield","peg$parsenegation","peg$parsematches","peg$parsehas","nth","peg$parsefirstChild","nthLast","peg$parselastChild","parseInt","peg$parsenthChild","peg$parsenthLastChild","peg$parsescope","peg$parseclass","n","index","factory","getPath","obj","keys","MATCHER_CACHE","WeakMap","getMatcher","selector","matcher","get","generateMatcher","set","toLowerCase","node","ancestry","nodeTypeKey","path","split","inPath","ancestor","fromPathIndex","current","field","isArray","k","matchers","estraverse","traverse","enter","unshift","leave","shift","visitorKeys","fallback","l","_typeof","sibling","adjacent","nthChild","matchClass","getVisitorKeys","nodeType","VisitorKeys","Object","filter","isNode","side","_slicedToArray","listProp","startIndex","indexOf","lowerBound","upperBound","idx","ast","visitor","altSubjects","subjects","results","sel","_toConsumableArray","m","succeedingAncestry","parser","query","matches"],"mappings":"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"}